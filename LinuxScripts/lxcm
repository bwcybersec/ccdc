#!/bin/bash
scriptName="$0"
# This tool was created by Ian Walton.
iface=$(ip route | grep default | sed 's/.*dev \([0-9a-z]*\) .*/\1/g' | head -n 1)
ip=$(ip addr show "$iface" | grep 'inet ' | tr -s ' /' ' ' | cut -f 3 -d ' ')
lxcmHome="/var/lib/lxcm"
filterBetweenContainers="true"
if [[ "$EDITOR" == "" ]]
then
    EDITOR="vim"
fi

if [[ -e "$lxcmHome/containers/seq" ]]
then
    mv "$lxcmHome/containers/seq" "$lxcmHome/seq"
fi

function lxcm_completion {
   lxcmHome="/var/lib/lxcm"
   
   _lxcm_template()
   {
       COMPREPLY=( $( compgen -W '$( command ls "$lxcmHome/templates/" | sed "s/\.sfs//g" )' \
           -- "$cur" ) )
   }
   
   _lxcm_os_template()
   {
       COMPREPLY=( $( compgen -W 'debian ubuntu centos alpine oracle' \
           -- "$cur" ) )
   }
   
   _lxcm_container()
   {
       COMPREPLY=( $( compgen -W '$( command ls "$lxcmHome/containers/" )' \
           -- "$cur" ) )
   }
   
   _lxcm_container_backup()
   {
       COMPREPLY=( $( compgen -W '$( command ls "$lxcmHome/containers/'"$1"'/backups/" | sed "s/\.sfs//g" )' \
           -- "$cur" ) )
   }
   
   _print_all()
   {
       while [[ "$1" != "" ]]
       do
           echo "$1"
           shift
       done
   }
   
   _lxcm_fs()
   {
       cur=${cur:=/}
       cur="/var/lib/lxc/$1/rootfs/$cur"
       _filedir
       COMPREPLY=( $( _print_all "${COMPREPLY[@]}" | sed 's#/var/lib/lxc/.*/rootfs/##g' ) )
   }
   
   _lxcm()
   {
       local cur prev words cword split
       _init_completion -s || return
       
       $split && return
   
       local arg
       _get_first_arg
       if [[ "$arg" == "" ]]
       then
           COMPREPLY=( $( compgen -W 'migrate template compress compose destroy-template
               list-templates ez new start stop restart edit-startup shell safe-shell
               execute clean ipt get put destroy-container list-containers forward
               list-forwards backup restore delete scrub list-backups force-restore
               inspect autostart service clear-passwords move-forwards remove-forwards clone fw' -- "$cur" ) )
       else
           local args
           _count_args
           case $arg in
               template)
                   case $args in
                       2)
                           _lxcm_os_template
                           ;;
                       3)
                           COMPREPLY=( "$prev" )
                           ;;
                       esac
                   ;;
               compress|destroy-template|new)
                   case $args in
                       2)
                           _lxcm_template
                           ;;
                       esac
                   ;;
               compose)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           COMPREPLY=( "$prev-template" )
                           ;;
                       esac
                   ;;
               start|stop|restart|edit-startup|shell|safe-shell|clean|ipt|destroy-container|scrub|list-backups|clear-passwords|remove-forwards)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       esac
                   ;;
               execute)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       *)
                           _command_offset $args
                           ;;
                       esac
                   ;;
               get)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           _lxcm_fs "$prev"
                           ;;
                       4)
                           _filedir
                           ;;
                       esac
                   ;;
               put)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           _filedir
                           ;;
                       4)
                           _lxcm_fs "${COMP_WORDS[2]}"
                           ;;
                       esac
                   ;;
               autostart)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           COMPREPLY=( $( compgen -W 'auto manual' -- "$cur" ) )
                           ;;
                       esac
                   ;;
               service)
                   case $args in
                       2)
                           COMPREPLY=( $( compgen -W 'start stop' -- "$cur" ) )
                           ;;
                       esac
                   ;;
               forward)
                   case $args in
                       2)
                           COMPREPLY=( $( compgen -W 'add remove' -- "$cur" ) )
                           ;;
                       3)
                           COMPREPLY=( $( compgen -W 'tcp udp both' -- "$cur" ) )
                           ;;
                       4)
                           COMPREPLY=( $( compgen -W '20 21 22 23 25 53 69 80 110 123 143 443 3306' -- "$cur" ) )
                           ;;
                       5)
                           COMPREPLY=( "$prev" )
                           ;;
                       6)
                           _lxcm_container
                           ;;
                       7)
                           COMPREPLY=( $( compgen -W 'private public host all' -- "$cur" ) )
                           ;;
                       esac
                   ;;
               move-forwards|clone)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           _lxcm_container
                           ;;
                       esac
                   ;;
               fw)
                   case $args in
                       2)
                           COMPREPLY=( $( compgen -W 'load save edit append clear reload exclusive' -- "$cur" ) )
                           ;;
                       3)
                           if [[ "$prev" =~ (load|save) ]]
                           then
                               _filedir
                           elif [[ "$prev" == "exclusive" ]]
                           then
                               COMPREPLY=( $( compgen -W 'yes no' -- "$cur" ) )
                           fi
                           ;;
                       esac
                   ;;
               backup)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           COMPREPLY=( "$(date +%FT%T)" )
                           ;;
                       esac
                   ;;
               restore|delete|inspect)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           _lxcm_container_backup "$prev"
                           ;;
                       esac
                   ;;
               force-restore)
                   case $args in
                       2)
                           _lxcm_container
                           ;;
                       3)
                           _lxcm_container_backup "$prev"
                           ;;
                       4)
                           _lxcm_container
                           ;;
                       esac
                   ;;
           esac
       fi
   } &&
   complete -F _lxcm lxcm

}

function install {
    if [[ "$1" != "postinst" ]]
    then
        cp "$scriptName" /usr/bin/lxcm
        chmod 755 /usr/bin/lxcm
        chown root:root /usr/bin/lxcm
        apt install -y acl squashfs-tools lxc unionfs-fuse bindfs vim whiptail bash-completion
    fi
    mkdir -p "$lxcmHome/templates/"
    chmod 700 "$lxcmHome"
    mkdir -p "$lxcmHome/containers/"
    touch "/var/lib/lxcm/forwards"
    echo "auto lxc-bridge-nat
iface lxc-bridge-nat inet static  
   bridge_ports none
   bridge_fd 0
   bridge_maxwait 0
   bridge_stp off
   address 192.168.100.1
   netmask 255.255.255.0
   up iptables -t nat -A POSTROUTING -o $iface -j MASQUERADE
   down iptables -t nat -D POSTROUTING -o $iface -j MASQUERADE
   post-up echo 1 > /proc/sys/net/ipv4/ip_forward" > /etc/network/interfaces.d/lxc-bridge-nat
    if ! grep -qF "Enable interfaces.d added by lxcm." /etc/network/interfaces
    then
        echo -e "\n# Enable interfaces.d added by lxcm.\nsource /etc/network/interfaces.d/*\n" >> /etc/network/interfaces
    fi
    /etc/init.d/networking restart
    echo "[Unit]
Description=LXCM Container Autostart
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/bin/lxcm service start
RemainAfterExit=true
ExecStop=/usr/bin/lxcm service stop
StandardOutput=journal

[Install]
WantedBy=multi-user.target" > /etc/systemd/system/lxcm.service
    systemctl enable lxcm
    cat /etc/network/interfaces | grep iface | grep -v lxc-bridge-nat | grep -v ' lo ' | cut -d ' ' -f 2 | while read ifen
    do
        ifup "$ifen"
    done
    if [[ "$(lxc-create --version)" =~ ^3 ]] && [[ "$1" != "postinst" ]]
    then
        apt install -y lxc-templates
    fi
    chmod 755 /var/lib/lxc
    completion_file="$HOME/lxcm-completion"
    if [[ -e /etc/bash_completion.d/ ]]
    then
        completion_file="/etc/bash_completion.d/lxcm-completion.bash"
    elif [[ -e /usr/share/bash-completion/completions/ ]]
    then
        completion_file="/usr/share/bash-completion/completions/lxcm"
    fi
    type lxcm_completion | grep '^   ' > "$completion_file"
    if [[ ! -e ~/.bashrc || "$(grep -v '^$\|^#' ~/.bashrc | wc -l)" == "0" ]] && [[ -e "/etc/skel/.bashrc" ]]
    then
        echo "You appear to have an empty bash configuration."
        read -p "Would you like to enable tab completion? [Y/n] " confirm
        if ! [[ "$confirm" =~ (n|N) ]]
        then
            cp /etc/skel/.bashrc ~/.bashrc
            if ! grep -q '^ *. /etc/bash_completion' ~/.bashrc
            then
                echo ". /etc/bash_completion" >> ~/.bashrc
            fi
        fi
    fi
    echo "You will need to restart your shell to enable completion."
    echo "Please type \"exec bash\"."
}

function migrate {
    #HOST TEMPLATE
    if [[ -e "$lxcmHome/templates/$1" || -e "$lxcmHome/templates/$1.sfs" ]]
    then
        echo "Template already exists."
        exit 1
    fi
    mkdir -p "$lxcmHome/templates/$2"
    cd "$lxcmHome/templates/$2"
    ssh "$1" tar -c --one-file-system / | tar -xv
}

function unsetPasswords {
    #SHADOW-FILE
    cat "$1" | sed 's/^\([^:]*\):\([^:]*\):\(.*\)$/\1\t\2\t\3/g' | while read -r line
    do
        {
            read -rd $'\t' user
            read -rd $'\t' password
            read -r other
        } <<< "$line"
        if ! [[ "$password" =~ (\*|\!) ]]
        then
            password="!"
        fi
        echo "$user:$password:$other"
    done > "$1.lxcm-temp"
    mv "$1.lxcm-temp" "$1"
}

function template {
    #LXC-TEMPLATE TEMPLATE
    if [[ -e "$lxcmHome/templates/$2" || -e "$lxcmHome/templates/$2.sfs" ]]
    then
        echo "Template already exists."
        exit 1
    fi
    if [[ "$1" =~ (centos|oracle) ]] && ! which yum 2>/dev/null
    then
        echo "Installing yum to allow for template creation..."
        apt install -y yum || return 1
    fi
    lxc-create -B dir -n lxcm-temp-create -t "$1" || exit 1
    unsetPasswords /var/lib/lxc/lxcm-temp-create/rootfs/etc/shadow
    mv "/var/lib/lxc/lxcm-temp-create/rootfs" "$lxcmHome/templates/$2"
    mkdir "/var/lib/lxc/lxcm-temp-create/rootfs"
    lxc-destroy -n lxcm-temp-create
}

function compose {
    #CONTAINER TEMPLATE
    if [[ -e "$lxcmHome/templates/$2" || -e "$lxcmHome/templates/$2.sfs" ]]
    then
        echo "Template already exists."
        exit 1
    fi
    if ! [[ "$1" != "" && -e "$lxcmHome/containers/$1" ]]
    then
        echo "Container does not exist."
        exit 1
    fi
    echo "Container must be stopped and left off while processing."
    read -p "Continue? [Y/n] " confirm
    if [[ "$confirm" =~ (n|N) ]]
    then
        exit 1
    fi
    stop "$1"
    mount-filesystem "$1"
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    mkdir "$lxcmHome/templates/$2"
    bindfs -o suid,dev --uid-offset="-${sNum}00000" --gid-offset="-${sNum}00000" "/var/lib/lxc/$1/rootfs" "$lxcmHome/templates/$2"
    cd "$lxcmHome/templates/$2"
    mksquashfs ./ ../"$2.sfs" -comp lzo -b 4096
    if [[ "$?" != "0" ]]
    then
        echo "Compression failed!"
        rm "$lxcmHome/templates/$2.sfs"
    fi
    cd /
    umount "$lxcmHome/templates/$2"
    rmdir "$lxcmHome/templates/$2"
    unmount-filesystem "$1"
}

function compress {
    #TEMPLATE
    if ! [[ "$1" != "" && -e "$lxcmHome/templates/$1" ]]
    then
        echo "Template does not exist."
        exit 1
    fi
    if [[ -e "$lxcmHome/templates/$1.sfs" ]]
    then
        echo "Template is compressed!"
        exit 1
    fi
    cd "$lxcmHome/templates/$1"
    mksquashfs ./ ../"$1.sfs" -comp lzo -b 4096
    if [[ "$?" != "0" ]]
    then
        echo "Compression failed!"
        rm "$lxcmHome/templates/$1.sfs"
        return
    fi
    cd /
    if check-template-op "$1" stop
    then
        rm -rf "$lxcmHome/templates/$1"
    else
        echo "You must manually run the command below"
        echo "to free disk space, after stopping the"
        echo "containers."
        echo "# rm -rf \"$lxcmHome/templates/$1\""
    fi
}

function destroy-template {
    #TEMPLATE
    if [[ "$1" == "" ]] || ! [[ -e "$lxcmHome/templates/$1" || -e "$lxcmHome/templates/$1.sfs" ]]
    then
        echo "Templates that do not exist cannot be destroyed!"
        exit
    fi
    echo "About to delete template $1."
    read -p "Are you sure? [y/N] " confirm
    if ! [[ "$confirm" =~ (y|Y) ]]
    then
        return 1
    fi
    check-template-op "$1" destroy || return 1
    cd /
    if [[ -e "$lxcmHome/templates/$1.sfs" ]]
    then
        umount "$lxcmHome/templates/$1" 2>/dev/null
        rm "$lxcmHome/templates/$1.sfs"
        rmdir "$lxcmHome/templates/$1"
    else
        rm -r "$lxcmHome/templates/$1"
    fi
}

function list-templates {
    ls $lxcmHome/templates/ | sed 's/.sfs$//g' | sort -u
}

function checkIdMap {
    #[type = subgid/subuid] [offset]
    offset="$2"
    id=$((offset*100000))
    idend=$((id+65536))
    while read -r line
    do
        {
            read -rd : user
            read -rd : start
            read -r count
        } <<< "$line"
        if ((idend > start)) && ((id < start+count))
        then
            #echo "Mapping $id-$((idend-1)) overlaps with $line."
            return 1
        fi
    done < /etc/$1
}

function findNextsNum {
    sNumMin=2
    sNumMax=254
    for i in $(seq "$sNumMin" "$sNumMax")
    do
        checkIdMap subgid $i || continue
        checkIdMap subuid $i || continue
        echo "$i"
        return
    done
    echo fail
}

function check-lxc-v3 {
    #CONTAINER
    if [[ "$(lxc-create --version)" =~ ^3 ]] && [[ ! -f "$lxcmHome/containers/$1/version-v3" ]]
    then
        echo "upgraded" > "$lxcmHome/containers/$1/version-v3"
        sNum=$(cat "$lxcmHome/containers/$1/sNum")
        echo "lxc.include = /usr/share/lxc/config/common.conf
lxc.tty.max = 4
lxc.uts.name = $1
lxc.arch = amd64
lxc.net.0.type = veth
lxc.net.0.flags = up
lxc.rootfs.path = /var/lib/lxc/$1/rootfs
lxc.mount.entry = shm /dev/shm tmpfs defaults 0 0
lxc.net.0.link = lxc-bridge-nat
lxc.net.0.ipv4.address = 192.168.100.$sNum/24
lxc.net.0.ipv4.gateway = 192.168.100.1
lxc.include = /usr/share/lxc/config/userns.conf
lxc.cgroup.pids.max = 5000
limits.memory = 256MB
limits.memory.enforce = soft
limits.cpu.allowance = 20%
lxc.idmap = u 0 ${sNum}00000 65536
lxc.idmap = g 0 ${sNum}00000 65536" > "/var/lib/lxc/$1/config"
    fi
}

function new {
    #TEMPLATE CONTAINER
    if [[ -e "$lxcmHome/containers/$2" ]]
    then
        echo "Container already exists."
        exit 1
    fi
    if [[ ! -e "$lxcmHome/templates/$1" && ! -e "$lxcmHome/templates/$1.sfs" ]]
    then
        echo "Template does not exist."
        exit 1
    fi
    sNum=$(findNextsNum)
    if [[ "$sNum" == "fail" ]]
    then
        echo "You have created too many containers!"
        echo "Please delete some containers and try again."
        exit 1
    fi
    mkdir -p "$lxcmHome/containers/$2"
    echo "$sNum" > "$lxcmHome/containers/$2/sNum"
    mkdir -p "$lxcmHome/containers/$2/backups"
    mkdir -p "$lxcmHome/containers/$2/unionmount"
    mkdir -p "$lxcmHome/containers/$2/scratchfs"
    chown "${sNum}00000:${sNum}00000" "$lxcmHome/containers/$2/scratchfs"
    echo "root:${sNum}00000:65536" >> /etc/subgid
    echo "root:${sNum}00000:65536" >> /etc/subuid
    echo "$1" > "$lxcmHome/containers/$2/template"
    > "$lxcmHome/containers/$2/fixed"
    lxc-create -n "$2" -B dir -t none
    mkdir "/var/lib/lxc/$2/rootfs"
    echo "lxc.include = /usr/share/lxc/config/common.conf
lxc.tty = 4
lxc.utsname = $2
lxc.arch = amd64
lxc.network.type = veth
lxc.network.flags = up
lxc.rootfs = /var/lib/lxc/$2/rootfs
lxc.rootfs.backend = dir
lxc.mount.entry = shm /dev/shm tmpfs defaults 0 0
lxc.network.link = lxc-bridge-nat
lxc.network.ipv4 = 192.168.100.$sNum/24
lxc.network.ipv4.gateway = 192.168.100.1
lxc.include = /usr/share/lxc/config/userns.conf
lxc.cgroup.pids.max = 5000
limits.memory = 256MB
limits.memory.enforce = soft
limits.cpu.allowance = 20%
lxc.id_map = u 0 ${sNum}00000 65536
lxc.id_map = g 0 ${sNum}00000 65536" > "/var/lib/lxc/$2/config"
    setfacl -m u:${sNum}00000:x "/var/lib/lxc/$2/"
    check-lxc-v3 "$2"
}

function mount-template {
    #TEMPLATE
    if [[ -e "$lxcmHome/templates/$1.sfs" ]]
    then
        if ! grep -q "$lxcmHome/templates/$1" <(mount | grep squashfs)
        then
            mkdir -p "$lxcmHome/templates/$1"
            mount "$lxcmHome/templates/$1.sfs" "$lxcmHome/templates/$1"
        fi
    fi
}

function mount-filesystem {
    #CONTAINER
    if [[ "$1" == "" ]]
    then
        echo "Refusing to mount filesystem without container name!"
        exit 1
    fi
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    if [[ ! -e "$lxcmHome/containers/$1/fixed" ]]
    then
        mkdir "$lxcmHome/containers/$1/fixedmnt"
        echo "Migrating filesystem..."
        bindfs -o suid,dev --uid-offset=${sNum}00000 --gid-offset=${sNum}00000 "$lxcmHome/containers/$1/scratchfs" "$lxcmHome/containers/$1/fixedmnt" || { echo failed to mount/convert; exit 1; }
        cp -rfa "$lxcmHome/containers/$1/fixedmnt" "$lxcmHome/containers/$1/fixedfs"
        read -p "Please confirm there were no errors and press enter."
        umount "$lxcmHome/containers/$1/fixedmnt"
        rm -rf "$lxcmHome/containers/$1/scratchfs"
        rmdir "$lxcmHome/containers/$1/fixedmnt"
        mv "$lxcmHome/containers/$1/fixedfs" "$lxcmHome/containers/$1/scratchfs"
        > "$lxcmHome/containers/$1/fixed"
    fi
    template=$(cat "$lxcmHome/containers/$1/template")
    mount-template "$template"
    if [[ ! -e "$lxcmHome/containers/$1/templatemount" ]]
    then
        mkdir "$lxcmHome/containers/$1/templatemount"
        mkdir "$lxcmHome/containers/$1/mnt"
        mkdir "$lxcmHome/containers/$1/backup"
    fi
    bindfs -o suid,dev --uid-offset=${sNum}00000 --gid-offset=${sNum}00000 "$lxcmHome/templates/$template" "$lxcmHome/containers/$1/templatemount"
    unionfs -o cow,allow_other,use_ino,suid,dev,nonempty "$lxcmHome/containers/$1/scratchfs"=RW:"$lxcmHome/containers/$1/templatemount" "/var/lib/lxc/$1/rootfs"
    if [[ ! -e "/var/lib/lxc/$1/rootfs/mnt" ]]
    then
        mkdir "/var/lib/lxc/$1/rootfs/mnt"
	chown "${sNum}00000:${sNum}00000" "/var/lib/lxc/$1/rootfs/mnt"
    fi
    if [[ ! -e "/var/lib/lxc/$1/rootfs/extrafs" ]]
    then
        mkdir -p "$lxcmHome/containers/$1/extrafs"
        mkdir "/var/lib/lxc/$1/rootfs/extrafs"
        chown "${sNum}00000:${sNum}00000" "/var/lib/lxc/$1/rootfs/extrafs"
    fi
    mount -o bind "$lxcmHome/containers/$1/extrafs" "/var/lib/lxc/$1/rootfs/extrafs"
    chown "${sNum}00000:${sNum}00000" "/var/lib/lxc/$1/rootfs/extrafs"
    bindfs -o suid,dev,nonempty --uid-offset="${sNum}00000" --gid-offset="${sNum}00000" "$lxcmHome/containers/$1/mnt" "/var/lib/lxc/$1/rootfs/mnt"
}

function restart {
    #CONTAINER
    stop "$1"
    start "$1"
}

function start {
    #CONTAINER [bg]
    if ! [[ -e "$lxcmHome/containers/$1" ]]
    then
        echo "Container does not exist."
        exit 1
    fi
    if grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        echo "Container $1 is already running!"
        exit 1
    fi
    stop "$1"
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    check-lxc-v3 "$1"
    update-port-forwards
    mount-filesystem "$1"
    echo "$1" > "/var/lib/lxc/$1/rootfs/etc/hostname"
    lxc-start -n "$1"
    sleep 2
    cp -a "/var/lib/lxc/$1/rootfs/etc/hosts" "/var/lib/lxc/$1/rootfs/etc/hosts.bak-lxcm"
    grep -vF '# added by lxcm' < "/var/lib/lxc/$1/rootfs/etc/hosts.bak-lxcm" > "/var/lib/lxc/$1/rootfs/etc/hosts"
    echo "127.0.0.1 $1 # added by lxcm" >> "/var/lib/lxc/$1/rootfs/etc/hosts"
    echo "127.0.0.1 $1.local # added by lxcm" >> "/var/lib/lxc/$1/rootfs/etc/hosts"
    echo "$ip conthost # added by lxcm" >> "/var/lib/lxc/$1/rootfs/etc/hosts"
    rm "/var/lib/lxc/$1/rootfs/etc/hosts.bak-lxcm"
    put "$1" /etc/localtime /etc/ct_localtime
    ln -sf /etc/ct_localtime "/var/lib/lxc/$1/rootfs/etc/localtime"
    if [[ "$filterBetweenContainers" == "true" ]]
    then
        ipt "$1" -A INPUT -s "192.168.100.$sNum" -d "192.168.100.$sNum" -j ACCEPT
        ipt "$1" -A OUTPUT -s "192.168.100.$sNum" -d "192.168.100.$sNum" -j ACCEPT
        ipt "$1" -A INPUT -s 192.168.100.0/24 -d 192.168.100.0/24 -j DROP
        ipt "$1" -A OUTPUT -s 192.168.100.0/24 -d 192.168.100.0/24 -j DROP
    fi
    if [[ -e "$lxcmHome/containers/$1/startup" ]]
    then
        function runAutostart {
            cat "$lxcmHome/containers/$1/startup" | lxc-attach -n "$1" --clear-env -- /bin/bash --norc --noprofile
        }
        if [[ "$2" == "bg" ]]
        then
            runAutostart "$1" < /dev/null &>/dev/null &
        else
            runAutostart "$1"
        fi
    fi
}

function ipt {
    #CONTAINER PARAMS...
    if ! grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        echo "You must start the container first!"
        exit 1
    fi
    container="$1"
    shift
    sNum=$(cat "$lxcmHome/containers/$container/sNum")
    nsPid=$(ps -aux | grep "^${sNum}00000" | head -n 1 | tr -s ' ' | cut -d ' ' -f 2)
    nsenter --net=/proc/$nsPid/ns/net iptables "$@"
}

function deleteFromPath {
    #CONTAINER COMMAND
    rm -f "/var/lib/lxc/$1/rootfs/sbin/$2" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/bin/$2" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/usr/sbin/$2" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/usr/bin/$2" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/usr/local/bin/$2" &>/dev/null
}

function clear-passwords {
    #CONTAINER
    if ! grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        echo "You must start the container first!"
        exit 1
    fi
    unsetPasswords "/var/lib/lxc/$1/rootfs/etc/shadow"
}

function clean {
    #CONTAINER
    if ! grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        echo "You must start the container first!"
        exit 1
    fi
    deleteFromPath "$1" sudo
    deleteFromPath "$1" iptables
    deleteFromPath "$1" su
    rm -f "/var/lib/lxc/$1/rootfs/root/.bashrc" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/root/.bash_profile" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/root/.bash_login" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/root/.profile" &>/dev/null
    rm -f "/var/lib/lxc/$1/rootfs/etc/profile" &>/dev/null
    cat /etc/bash.bashrc > "/var/lib/lxc/$1/rootfs/etc/bash.bashrc"
    cat /etc/bash.bashrc | lxc-attach -n "$1" --clear-env -- /bin/bash --norc --noprofile -c 'cat > /root/.bashrc'
}

function stop {
    #CONTAINER
    if grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        lxc-stop -n "$1" -t 30
        unmount-filesystem "$1"
    fi
    unmount-filesystem "$1" 2> /dev/null
}

function unmount-filesystem {
    #CONTAINER
    umount "/var/lib/lxc/$1/rootfs/extrafs"
    umount "/var/lib/lxc/$1/rootfs/mnt"
    #umount "$lxcmHome/containers/$1/backup"
    umount "/var/lib/lxc/$1/rootfs"
    umount "$lxcmHome/containers/$1/templatemount"
}

function edit-startup {
    #CONTAINER
    $EDITOR "$lxcmHome/containers/$1/startup"
}

function autostart {
    #CONTAINER manual/auto
    if [[ "$2" == "auto" ]]
    then
        echo "auto" > "$lxcmHome/containers/$1/autostart"
    else
        rm "$lxcmHome/containers/$1/autostart"
    fi
}

function service {
    #start/stop
    if [[ "$1" == "start" ]]
    then
        update-port-forwards
        if [[ -f "$lxcmHome/firewall" ]]
        then
            fw reload
        fi
        ls "$lxcmHome/containers/" | while read -r container
        do
            if [[ -e "$lxcmHome/containers/$container/autostart" ]]
            then
                echo "Starting container $container..."
                start "$container" bg
            fi
        done
    elif [[ "$1" == "stop" ]]
    then
        ls "$lxcmHome/containers/" | while read -r container
        do
            if checkContainerStarted "$container"
            then
                echo "Stopping container $container..."
                stop "$container"
            fi
        done
    fi
}

function shell {
    #CONTAINER
    if ! checkContainerStarted "$1"
    then
        echo "The container \"$1\" is not started."
        read -p "Would you like to start it? [Y/n] " confirm
        if ! [[ "$confirm" =~ (N|n) ]]
        then
            start "$1"
        fi
    fi
    unset PROMPT_COMMAND
    lxc-attach -n "$1"
}

function resolveName {
    #NAME
    resp=""
    while read -r line
    do
        if [[ "$line" == "" ]]
        then
            continue
        fi
        answer=""
        if [[ "$line" =~ ^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*(:[0-9]*|/[0-9]*)*$ ]]
        then
            answer="$line"
        else
            if [[ -f "/tmp/fwalias/$line" ]]
            then
                answer="$(cat "/tmp/fwalias/$line")"
            elif [[ -e "$lxcmHome/containers/$line/" ]]
            then
                sNum=$(cat "$lxcmHome/containers/$line/sNum")
                answer="192.168.100.$sNum"
            else
                echo "Warning: No Alias/Container for: $line" >&2
                continue
            fi
        fi
        if [[ "$resp" == "" ]]
        then
            resp="$answer"
        else
            resp="$resp,$answer"
        fi
    done < <(echo "$1" | tr ',' '\n')
    echo "$resp"
}

function fwappend {
    #POLICY
    fullRule="$*"
    if [[ "$1" == "alias" ]]
    then
        result=$(resolveName "$3")
	if [[ "$result" != "" ]]
        then
            echo "$result" > "/tmp/fwalias/$2"
        else
            echo "Blank alias: $2"
        fi
    elif [[ "$1" =~ ^(local|out|outc|in|inc)$ ]]
    then
        sip=""
        if [[ "$1" == "local" ]]
        then
            interface="lxc-bridge-nat"
            chain="lxcm_forward"
            direction="i"
            sip="192.168.100.0/24"
        elif [[ "$1" == "out" ]]
        then
            interface="$iface"
            chain="lxcm_output"
            direction="o"
            cdir="i"
            cchain="lxcm_input"
        elif [[ "$1" == "in" ]]
        then
            interface="$iface"
            chain="lxcm_input"
            direction="i"
            cdir="o"
            cchain="lxcm_output"
        elif [[ "$1" == "inc" ]]
        then
            interface="$iface"
            chain="lxcm_forward"
            direction="i"
            cdir="o"
            cchain="lxcm_forward"
        elif [[ "$1" == "outc" ]]
        then
            interface="$iface"
            chain="lxcm_forward"
            direction="o"
            cdir="i"
            cchain="lxcm_forward"
        fi
        shift
        rule="-A $chain -$direction $interface"
        crule="-A $cchain -$cdir $interface"
        applyCr="false"
        arule=""
        acrule=""
        if [[ "$1" =~ (tcp|udp) ]]
        then
            protocol="$1"
            shift
            port="$1"
            shift
            if [[ "$port" =~ , ]]
            then
                rule="$rule -p $protocol -m multiport --dports $port"
                crule="$crule -p $protocol -m multiport --sports $port"
            else
                rule="$rule -p $protocol --dport $port"
                crule="$crule -p $protocol --sport $port"
            fi
            if [[ "$protocol" == "udp" ]]
            then
                applyCr="true"
            fi
        fi
        if [[ "$1" == "allow" ]]
        then
            rule="$rule $arule -j ACCEPT"
            crule="$crule $acrule -j ACCEPT"
        elif [[ "$1" == "deny" ]]
        then
            rule="$rule -j lxcm_log_and_drop"
            applyCr="false"
        else
            echo "Bad Rule: $fullRule"
            return
        fi
        shift
        if [[ "$1" != "to" && "$1" != "" ]]
        then
            result=$(resolveName "$1")
            if [[ "$result" == "" ]]
            then
                echo "Ignored Rule: $fullRule"
            fi
            rule="$rule -s $result"
            crule="$crule -d $result"
            shift
        elif [[ "$sip" != "" ]]
        then
            rule="$rule -s $sip"
            crule="$crule -d $sip"
        fi
        if [[ "$1" == "to" ]]
        then
            result=$(resolveName "$2")
            if [[ "$result" == "" ]]
            then
                echo "Ignored Rule: $fullRule"
            fi
            rule="$rule -d $result"
            crule="$crule -s $result"
        fi
        iptables $rule || echo "Bad rule: $fullRule"
        if [[ "$cchain" != "" && "$applyCr" = "true" ]]
        then
            iptables $crule || echo "Bad rule: $fullRule"
        fi
    else
        echo "Bad rule: $fullRule"
        return
    fi
}

function load-firewall {
    iptables -P INPUT DROP
    iptables -P OUTPUT DROP
    iptables -P FORWARD DROP
    if [[ -e "$lxcmHome/firewall-exclusive" ]]
    then
        iptables -F
    fi
    iptables_diversion lxcm_input INPUT
    iptables_diversion lxcm_output OUTPUT
    iptables_diversion lxcm_forward FORWARD
    iptables -N lxcm_log_and_drop 2>/dev/null
    iptables -F lxcm_log_and_drop
    iptables -A lxcm_log_and_drop -m limit --limit 5/min -j LOG --log-prefix "Denied: " --log-level 7
    iptables -A lxcm_log_and_drop -j DROP
    iptables -A lxcm_forward -i "$iface" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT ||
        iptables -A lxcm_forward -i "$iface" -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A lxcm_forward -o "$iface" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT ||
        iptables -A lxcm_forward -o "$iface" -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A lxcm_input -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT ||
        iptables -A lxcm_input -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A lxcm_output -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT ||
        iptables -A lxcm_output -m state --state ESTABLISHED,RELATED -j ACCEPT
    mkdir "/tmp/fwalias/"
    grep '^alias' "$1" | grep -v '^$\|^#' | while read -r policy
    do
        fwappend $policy
    done
    grep -v '^alias' "$1" | grep -v '^$\|^#' | while read -r policy
    do
        fwappend $policy
    done
    rm -r "/tmp/fwalias/"
    iptables -P INPUT ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -P FORWARD ACCEPT
}

function fw {
    if [[ ! -e "/var/lib/lxcm/" ]]
    then
        mkdir -p "/var/lib/lxcm/"
    fi
    if [[ "$1" == "load" ]]
    then
        cp "$2" "$lxcmHome/firewall"
        load-firewall "$lxcmHome/firewall"
    elif [[ "$1" == "save" ]]
    then
        cp "$lxcmHome/firewall" "$2"
    elif [[ "$1" == "edit" ]]
    then
        $EDITOR "$lxcmHome/firewall"
        load-firewall "$lxcmHome/firewall"
    elif [[ "$1" == "reload" ]]
    then
        load-firewall "$lxcmHome/firewall"
    elif [[ "$1" == "append" ]]
    then
        shift
        echo "$*" >> "$lxcmHome/firewall"
    elif [[ "$1" == "clear" ]]
    then
        > "$lxcmHome/firewall"
    elif [[ "$1" == "exclusive" ]]
    then
        if [[ "$2" == "yes" ]]
        then
            touch "$lxcmHome/firewall"
            touch "$lxcmHome/firewall-exclusive"
            load-firewall "$lxcmHome/firewall"
        elif [[ "$2" == "no" ]]
        then
            rm "$lxcmHome/firewall-exclusive"
        fi
    fi
}

function safe-shell {
    #CONTAINER
    lxc-attach -n "$1" --clear-env -- /bin/bash --noprofile --norc
}

function execute {
    #CONTAINER COMMAND PARAMS...
    container="$1"
    shift
    lxc-attach -n "$container" --clear-env -- "$@"
}

function checkContainerStarted {
    #CONTAINER
    if grep -q "^$1 *RUNNING" <(lxc-ls --fancy)
    then
        return
    else
        return 1
    fi
}

function put {
    #CONTAINER LOCAL-PATH [CONTANER-PATH]    
    if ! checkContainerStarted "$1"
    then
        echo "Container must be running to copy files."
        exit 1
    fi
    if [[ "$3" == "" ]]
    then
        copyTo="/"
    else
        copyTo="$3"
    fi

    filename=$(basename "$2")
    cp -rfa "$2" "$lxcmHome/containers/$1/mnt/"
    mv "/var/lib/lxc/$1/rootfs/mnt/$filename" "/var/lib/lxc/$1/rootfs/$copyTo"
}

function get {
    #CONTAINER CONTANER-PATH [LOCAL-PATH]
    if ! checkContainerStarted "$1"
    then
        echo "Container must be running to copy files."
        exit 1
    fi
    if [[ "$3" == "" ]]
    then
        copyTo="./"
    else
        copyTo="$3"
    fi

    filename=$(basename "$2")
    execute "$1" cp -rfa "/$2" "/mnt/"
    mv "$lxcmHome/containers/$1/mnt/$filename" "$copyTo" 
}

function check-template-op {
    #check-template-op TEMPLATE OPERATION
    ctcount=0
    cts=""
    echo "Containers affected by this operation:"
    while read cont
    do
        if [[ "$(cat "$lxcmHome/containers/$cont/template")" == "$1" ]]
        then
            if [[ "$2" != "stop" ]] || grep -q "^$cont *RUNNING" <(lxc-ls --fancy)
            then
                echo "    $cont"
                ((ctcount++))
                cts="$cts|$cont"
            fi
        fi
    done < <(ls "$lxcmHome/containers/")
    if [[ "$ctcount" == "0" ]]
    then
        return 0
    fi
    if [[ "$2" == "stop" ]]
    then
        read -p "Stop these containers? [y/N] " confirm
        if ! [[ "$confirm" =~ (y|Y) ]]
        then
            return 1
        fi
        echo "$cts" | tr '|' '\n' | while read cont
        do
            if [[ "$cont" == "" ]]
            then
                continue
            fi
            stop "$cont"
        done
    elif [[ "$2" == "destroy" ]]
    then
        echo "NOTE: Destroying a container deletes its backups!"
        read -p "DESTROY (!) these containers? [y/N] " confirm
        if ! [[ "$confirm" =~ (y|Y) ]]
        then
            return 1
        fi
        echo "$cts" | tr '|' '\n' | while read cont
        do
            if [[ "$cont" == "" ]]
            then
                continue
            fi
            destroy-container "$cont" noconfirm
        done
    fi
    return 0
}

function destroy-container {
    #CONTAINER [noconfirm]
    if [[ "$1" == "" || ! -e "$lxcmHome/containers/$1/" ]]
    then
        echo "You can't destroy a container that doesn't exist!"
        return 1
    fi
    if [[ "$2" != "noconfirm" ]]
    then
        echo "NOTE: Destroying a container deletes its backups!"
        read -p "DESTROY (!) container \"$1\" ? [y/N] " confirm
        if ! [[ "$confirm" =~ (y|Y) ]]
        then
            return 1
        fi
    fi
    stop "$1"
    unmount-filesystem "$1" 2>/dev/null
    umount "$lxcmHome/containers/$1/temp-mount/"* 2>/dev/null
    umount "$lxcmHome/containers/$1/temp-mount/"* 2>/dev/null
    lxc-destroy -n "$1"
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    grep -vF "root:${sNum}00000:65536" /etc/subgid > /etc/subgid.lxcm-temp
    mv /etc/subgid.lxcm-temp /etc/subgid
    grep -vF "root:${sNum}00000:65536" /etc/subuid > /etc/subuid.lxcm-temp
    mv /etc/subuid.lxcm-temp /etc/subuid
    rm -r "$lxcmHome/containers/$1/"
}

function list-containers {
    ls "$lxcmHome/containers/"
}

function iptables_diversion {
    #NAME CHAIN [type]
    iptables $3 -N $1 2> /dev/null
    iptables $3 -F $1
    iptables $3 -D $2 -j $1 2> /dev/null
    iptables $3 -A $2 -j $1
}

function update-port-forwards {
    grep -vF "# added by lxcm" < /etc/hosts > /etc/hosts.bak-lxcm
    mv /etc/hosts.bak-lxcm /etc/hosts
    echo "$ip conthost # added by lxcm" >> /etc/hosts
    if [[ -e "$lxcmHome/firewall-exclusive" ]]
    then
        iptables -t nat -F
    fi
    iptables_diversion lxcm_prerouting PREROUTING "-t nat"
    iptables_diversion lxcm_output OUTPUT "-t nat"
    iptables_diversion lxcm_postrouting POSTROUTING "-t nat"
    iptables -t nat -A lxcm_postrouting -o $iface -j MASQUERADE
    sysctl -w net.ipv4.conf.all.route_localnet=1 &>/dev/null
    cat "$lxcmHome/forwards" | while read line
    do
        protocol=$(cut -d: -f1 <<< "$line")
        hport=$(cut -d: -f2 <<< "$line" | tr '-' ':')
        sport=$(cut -d: -f3 <<< "$line")
        container=$(cut -d: -f4 <<< "$line")
        mode=$(cut -d: -f5 <<< "$line")
        if [[ ! -e "$lxcmHome/containers/$container/sNum" ]]
        then
            echo "Ignored forward for $container: Container does not exist."
            continue
        fi
        sNum=$(cat "$lxcmHome/containers/$container/sNum")
        iptables -t nat -A lxcm_output -p "$protocol" -o "$iface" --dport "$hport" -j DNAT -d "$ip" --to-destination "192.168.100.$sNum:$sport"
        iptables -t nat -A lxcm_output -p "$protocol" -o lo --dport "$hport" -j DNAT --to-destination "192.168.100.$sNum:$sport"
        if ! [[ "$mode" =~ (public|host) ]]
        then
            iptables -t nat -A lxcm_prerouting -p "$protocol" -i lxc-bridge-nat --dport "$hport" -j DNAT -d "$ip" --to-destination "192.168.100.$sNum:$sport"
            iptables -t nat -A lxcm_postrouting -o lxc-bridge-nat -s 192.168.100.0/24 -p "$protocol" -m "$protocol" --dport "$hport" -j SNAT --to-source "$ip"
        fi
        if ! [[ $mode =~ (private|host) ]]
        then
            iptables -t nat -A lxcm_prerouting -p "$protocol" -i "$iface" --dport "$hport" -j DNAT --to-destination "192.168.100.$sNum:$sport"
        fi
    done
}

function forward {
    #add/delete tcp/udp/both HPORT CPORT CONTAINER [private/public/all]
    if ! [[ -e "$lxcmHome/containers/$5" || "$1" == "remove" ]]
    then
        echo "Container does not exist."
        exit 1
    fi
    mode="$6"
    if [[ ! "$6" =~ (private|public|host) ]]
    then
        mode="all"
    fi
    if [[ "$2" == "both" ]]
    then
        forward "$1" "udp" "$3" "$4" "$5" "$mode"
        forward "$1" "tcp" "$3" "$4" "$5" "$mode"
    elif [[ "$1" == "add" ]]
    then
        sort -u < "$lxcmHome/forwards" | grep -v "^$2:$3:$4:$5:" > "$lxcmHome/forwards.tmp"
        mv "$lxcmHome/forwards.tmp" "$lxcmHome/forwards"
        echo "$2:$3:$4:$5:$mode" >> "$lxcmHome/forwards"
    elif [[ "$1" == "remove" ]]
    then
        grep -vxF "$2:$3:$4:$5:$mode" < "$lxcmHome/forwards" > "$lxcmHome/forwards.tmp"
        mv "$lxcmHome/forwards.tmp" "$lxcmHome/forwards"
    fi
    update-port-forwards
}

function list-forwards {
    cat "$lxcmHome/forwards" | tr ':' ' '
}

function move-forwards {
    #OCONTAINER NCONTAINER
    touch "$lxcmHome/forwards-upd"
    cat "$lxcmHome/forwards" | while read -r forward
    do
        {
            read -rd: protocol
            read -rd: hport
            read -rd: sport
            read -rd: container
            read -r mode
        } <<< "$forward"
        if [[ "$container" == "$1" ]]
        then
            container="$2"
            if [[ "$3" == "DELETE_FORWARDS" ]]
            then
                continue
            fi
            echo "$protocol $hport $sport $container $mode"
        fi
        echo "$protocol:$hport:$sport:$container:$mode" >> "$lxcmHome/forwards-upd"
    done
    mv "$lxcmHome/forwards-upd" "$lxcmHome/forwards"
    update-port-forwards
}

function remove-forwards {
    #CONTAINER
    move-forwards "$1" "" DELETE_FORWARDS
}

function backup {
    #CONTAINER BACKUP
    if [[ -e "$lxcmHome/containers/$1/backups/$2.sfs" ]]
    then
	echo "Backup already exists."
    	exit 1
    fi
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    bindfs -o suid,dev --uid-offset="-${sNum}00000" --gid-offset="-${sNum}00000" "$lxcmHome/containers/$1/scratchfs" "$lxcmHome/containers/$1/backup"
    mount -o bind "$lxcmHome/containers/$1/scratchfs/.unionfs-fuse" "$lxcmHome/containers/$1/backup/.unionfs-fuse"
    cd "$lxcmHome/containers/$1/backup"
    mksquashfs ./ "$lxcmHome/containers/$1/backups/$2.sfs" -comp lzo -b 4096
    cd /
    umount "$lxcmHome/containers/$1/backup/.unionfs-fuse"
    umount "$lxcmHome/containers/$1/backup"
}

function inspect {
    #CONTAINER BACKUP
    if ! [[ -e "$lxcmHome/containers/$1/backups/$2.sfs" ]]
    then
        echo "Backup does not exist."
        exit 1
    fi
    if [[ ! -e "$lxcmHome/containers/$1/temp-mount/$2" ]]
    then
        backupHash=$(md5sum <<< "$2")
        backupHash=${backupHash:0:10}
        mkdir -p "$lxcmHome/containers/$1/temp-mount/$backupHash-unmerged"
        mkdir -p "$lxcmHome/containers/$1/temp-mount/$2"
        template=$(cat "$lxcmHome/containers/$1/template")
        mount-template "$template"
        mount "$lxcmHome/containers/$1/backups/$2.sfs" "$lxcmHome/containers/$1/temp-mount/$backupHash-unmerged"
        unionfs -o cow,allow_other,use_ino,suid,dev,nonempty "$lxcmHome/containers/$1/temp-mount/$backupHash-unmerged":"$lxcmHome/templates/$template" "$lxcmHome/containers/$1/temp-mount/$2"
        echo "Mounted to: $lxcmHome/containers/$1/temp-mount/$2"
    else
        echo "Already mounted to: $lxcmHome/containers/$1/temp-mount/$2"
    fi
    read -p "Open a shell there? [Y/n] " confirm
    if ! [[ "$confirm" =~ (n|N) ]]
    then
        cd "$lxcmHome/containers/$1/temp-mount/$2"
        bash
    fi
}

function restore {
    #CONTAINER BACKUP [nobackup]
    if ! [[ -e "$lxcmHome/containers/$1/backups/$2.sfs" ]]
    then
        echo "Backup does not exist."
        exit 1
    fi
    stop "$1"
    if [[ "$3" != "nobackup" ]]
    then
        read -p "Create backup first? [Y/n] " confirm
        if ! [[ "$confirm" =~ (n|N) ]]
        then
            backup "$1" "$(date +%FT%T)-dirty"
        fi
    fi
    rm -r "$lxcmHome/containers/$1/scratchfs"
    cd "$lxcmHome/containers/$1/"
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    mkdir "$lxcmHome/containers/$1/tmp"
    mkdir "$lxcmHome/containers/$1/tmp2"
    mount "$lxcmHome/containers/$1/backups/$2.sfs" "$lxcmHome/containers/$1/tmp"
    bindfs -o suid,dev --uid-offset="${sNum}00000" --gid-offset="${sNum}00000" "$lxcmHome/containers/$1/tmp" "$lxcmHome/containers/$1/tmp2"
    mount -o bind "$lxcmHome/containers/$1/tmp/.unionfs-fuse" "$lxcmHome/containers/$1/tmp2/.unionfs-fuse"
    cp -rfva "$lxcmHome/containers/$1/tmp2" "$lxcmHome/containers/$1/scratchfs"
    umount "$lxcmHome/containers/$1/tmp2/.unionfs-fuse"
    umount "$lxcmHome/containers/$1/tmp2"
    umount "$lxcmHome/containers/$1/tmp"
    rmdir "$lxcmHome/containers/$1/tmp2" "$lxcmHome/containers/$1/tmp"
    chown "${sNum}00000:${sNum}00000" "$lxcmHome/containers/$1/scratchfs"
}

function force-restore {
    #O-CONTAINER BACKUP D-CONTAINER [noconfirm]
    if [[ "$4" != "noconfirm" ]]
    then
        echo "WARNING: This operation is DANGEROUS!"
        read -p "Are you sure? [y/N] " confirm
        if ! [[ "$confirm" =~ (y|Y) ]]
        then
            exit
        fi
    fi
    stop "$3"
    ln -s "$lxcmHome/containers/$1/backups/$2.sfs" "$lxcmHome/containers/$3/backups/$2.sfs"
    restore "$3" "$2" nobackup
    rm "$lxcmHome/containers/$3/backups/$2.sfs"
}

function delete {
    #CONTAINER BACKUP
    backupHash=$(md5sum <<< "$2")
    backupHash=${backupHash:0:10}
    umount "$lxcmHome/containers/$1/temp-mount/$2" 2>/dev/null
    umount "$lxcmHome/containers/$1/temp-mount/$backupHash-unmerged" 2>/dev/null
    rmdir "$lxcmHome/containers/$1/temp-mount/$2" \
        "$lxcmHome/containers/$1/temp-mount/$backupHash-unmerged" 2>/dev/null
    rm "$lxcmHome/containers/$1/backups/$2.sfs"
}

function list-backups {
    #CONTAINER
    ls "$lxcmHome/containers/$1/backups/" | sed 's/.sfs$//g'
}

function scrub {
    #CONTAINER
    read -p "Create backup first? [Y/n] " confirm
    stop "$1"
    if ! [[ "$confirm" =~ (n|N) ]]
    then
        backup "$1" "$(date +%FT%T)-dirty"
    fi
    rm -r "$lxcmHome/containers/$1/scratchfs"
    mkdir "$lxcmHome/containers/$1/scratchfs"
    sNum=$(cat "$lxcmHome/containers/$1/sNum")
    chown "${sNum}00000:${sNum}00000" "$lxcmHome/containers/$1/scratchfs"
}

function listBox {
    #[question] [action text] Ask and store result into answer variable.
    question="$1"
    tmpfile="/tmp/$RANDOM$RANDOM"
    shift
    whiptail --title "lxcm interactive" --menu "$question" 0 0 0 "$@" 2> "$tmpfile"
    status="$?"
    answer="$(cat "$tmpfile")"
    rm "$tmpfile"
    return $status
}

function yesNo {
    #[question] [--defaultno]
    whiptail --title "lxcm interactive" --yesno "$1" 0 0 "$2"
    return $?
}

function inputBox {
    #[question] [initial] Answer will be saved to answer.
    tmpfile="/tmp/$RANDOM$RANDOM"
    whiptail --title "lxcm interactive" --inputbox "$1" 0 0 "$2" 2> "$tmpfile"
    status="$?"
    answer="$(cat "$tmpfile")"
    rm "$tmpfile"
    return $status
}

function e {
    NEWT_COLORS='root=,red' whiptail --title "lxcm interactive" --msgbox "$1" 0 0
    exit 1
}

function checkForOld {
    if [[ -d "/old" ]]
    then
        echo old Create_from_previous_os
    fi
}

function ensure-template {
    # [lxc-template] [template]
    if [[ ! -e "$lxcmHome/templates/$1" ]] && [[ ! -e "$lxcmHome/templates/$1.sfs" ]]
    then
        template "$1" "$2"
    fi
}

function clone {
    # OCONTAINER NCONTAINER
    backupName="clone-backup-$(date +%FT%T)"
    backup "$1" "$backupName" || return 1
    new "$(cat "$lxcmHome/containers/$1/template")" "$2" || return 1
    force-restore "$1" "$backupName" "$2" noconfirm
}

function ez-select-container {
    # Result will be stored in container variable.
    listBox "Please select a container to use as the basis for this template." \
        $(list-containers | sed 's/\(.*\)/\1 Use_container_\1/g') || return 1
    container="$answer"
}

function ez-select-template {
    # [new/existing]
    # Result will be stored in template variable.
    templateList=""
    if [[ "$1" != "new" ]]
    then
        templateList="$(list-templates | sed 's/\(.*\)/\1 Use_template_\1/g')"
    fi
    if [[ "$1" == "existing" ]]
    then
        listBox "Please select a template to use as the basis for the new container." \
            $templateList || return 1
    else
        listBox "Please select a template to use as the basis for the new container." \
            $templateList \
            "new" "Create from distribution template." \
            "migrate" "Create from existing system via ssh." \
            "compose" "Create from existing container." \
            $(checkForOld) || return 1
    fi

    creatingTemplate="false"
    template="$answer"
    if [[ "$answer" == "old" ]] && [[ ! -e "$lxcmHome/templates/old" && ! -e "$lxcmHome/templates/old.sfs" ]]
    then
        creatingTemplate="true"
        inputBox "Enter a name for the template." "old" || return 1
        template="$answer"
        [[ "$template" == "" ]] && e "You didn't provide a name!"
        mv /old "$lxcmHome/templates/$template"
    elif [[ "$answer" == "new" ]]
    then
        creatingTemplate="true"
        listBox "Please select the operating system for the template." \
            "debian" "Install Debian" \
            "ubuntu" "Install Ubuntu" \
            "centos" "Install CentOS" \
            "alpine" "Install Alpine" \
            "oracle" "Install Oracle" || return 1
        templateOS="$answer"
        inputBox "Enter a name for the template." "$templateOS" || return 1
        template="$answer"
        [[ "$template" == "" ]] && e "You didn't provide a name!"
        template "$templateOS" "$template" || return 1
    elif [[ "$answer" == "migrate" ]]
    then
        creatingTemplate="true"
        inputBox "Enter the ip address or hostname of the system. Root login is required." || return 1
        host="$answer"
        inputBox "Enter a name for the template." || return 1
        template="$answer"
        [[ "$template" == "" ]] && e "You didn't provide a name!"
        migrate "$host" "$template" || return 1
    elif [[ "$answer" == "compose" ]]
    then
        creatingTemplate="true"
        ez-select-container || return 1
        templateSource="$container"
        inputBox "Enter a name for the template." "$templateSource-template" || return 1
        template="$answer"
        [[ "$template" == "" ]] && e "You didn't provide a name!"
        compose "$templateSource" "$template" || return 1
    fi

    if [[ "$creatingTemplate" == "true" ]]
    then
        if yesNo "Would you like to compress this template?" --defaultno
        then
            compress "$template"
        fi
    fi
}

function ez {
    ez-select-template || exit 1
    inputBox "Enter a name for the container." || exit 1
    ctname="$answer"
    [[ "$ctname" == "" ]] && e "You didn't provide a name!"
    new "$template" "$ctname" || exit 1

    if yesNo "Would you like to edit the container startup?" --defaultno
    then
        EDITOR=nano edit-startup "$ctname"
    fi

    if yesNo "Should the container automatically start with the system?" --defaultno
    then                                        
        autostart "$ctname" auto
    fi

    if yesNo "Would you like to start the container?"
    then
        start "$ctname"
    fi
}

action="$1"
shift
if [[ "$(type "$action" 2> /dev/null)" =~ function ]]
then
    "$action" "$@"
elif [[ "$0" =~ lxcm$ ]]
then
    echo "lxcm - Linux Container Management Frontend

lxcm ACTION PARAMS...

where ACTION is:
    install - Install lxcm.
    
    migrate HOST TEMPLATE - Create template from system.
    template LXC-TEMPLATE TEMPLATE - Create template from lxc template.
    compress TEMPLATE - Compress a template.
    compose CONTAINER TEMPLATE - Convert container to template.
    destroy-template TEMPLATE - Delete a template.
    list-templates - List all templates.

    ez - Create a container (and template) using a wizard.
    new TEMPLATE CONTAINER - Create a container from a template.
    start CONTAINER - Start specified container.
    stop CONTAINER - Stop specified container.
    restart CONTAINER - Restart the specified container.
    edit-startup CONTAINER - Edit container startup.
    shell CONTAINER - Open a shell in container.
    safe-shell CONTAINER - Open shell without bash configs. (Not needed after clean.)
    execute CONTAINER COMMAND PARAMS... - Execute command in container.
    clean CONTAINER - Remove un-needed functionality for increased security.
    clear-passwords - Remove all passwords from container. (May break user logins.)
    ipt CONTAINER PARAMS... - Execute iptables in container. (Changes don't persist.)
    clone OCONTAINER NCONTAINER - Create a clone of a container.
    get CONTAINER CONTANER-PATH [LOCAL-PATH] - Copy file from container.
    put CONTAINER LOCAL-PATH [CONTANER-PATH] - Copy file to container.
    destroy-container - Delete a container.
    list-containers - List all containers.

    autostart CONTAINER manual/auto - Set startup setting.
    service start - Load firewalls and start all autostart containers.
    service stop - Stop all autostart containers.

    forward add tcp/udp/both HPORT CPORT CONTAINER [private/public/host/all] - Add a port forward.
    forward remove tcp/udp/both HPORT CPORT CONTAINER [private/public/host/all] - Delete a port forward.
    list-forwards - List all port forwards.
    move-forwards OCONTAINER NCONTAINER - Switch all forwards from one container to another.
    remove-forwards CONTAINER - Remove all forwards for a container.

    fw load FILE - Load firewall rules from file.
    fw save FILE - Save firewall rules to file.
    fw edit - Edit and reapply firewall rules.
    fw append - Append rules to firewall. (Requires reload.)
    fw clear - Clear firewall. (Requires reload.)
    fw reload - Reload current firewall. Works after reboot.
    fw exclusive yes/no - Set exclusive firewall mode.

    backup CONTAINER BACKUP - Backup the container.
    restore CONTAINER BACKUP - Restore a backup.
    delete CONTAINER BACKUP - Delete the backup.
    scrub CONTAINER - Revert container to template.
    list-backups CONTAINER - List all backups for container.
    force-restore O-CONTAINER BACKUP D-CONTAINER - Restore backups from different containers!
    inspect CONTAINER BACKUP - Mount a backup for analysis.

    Firewall policies have 6 commands:
        alias name ip, (can have multiple with commas)
        local [tcp/udp port] allow/deny [container,]
        outc [tcp/udp port] allow/deny [container,] [to alias/ip,]
        inc [tcp/udp port] allow/deny [alias/ip,] [to container,]
        in [tcp/udp port] allow/deny [alias/ip,]
        out [tcp/udp port] allow/deny [to alias/ip,]"
fi
